###############################################################################
# Copyright (c) 2000, 2018 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# https://www.eclipse.org/legal/epl-v10.html
# 
# This is an implementation of an early-draft specification developed under the Java
# Community Process (JCP) and is made available for testing and evaluation purposes
# only. The code is not compatible with any specification of the JCP.
#
# Contributors:
#     IBM Corporation - initial API and implementation
#		Benjamin Muskalla - Contribution for bug 239066
#		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
#							bug 185682 - Increment/decrement operators mark local variables as read
#							bug 349326 - [1.7] new warning for missing try-with-resources
#							bug 186342 - [compiler][null] Using annotations for null checking
#							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
#							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
#							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
#							bug 374605 - Unreasonable warning for enum-based switch statements
#							bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
#							bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
#							bug 388281 - [compiler][null] inheritance of null annotations as an option
#							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
#							bug 393719 - [compiler] inconsistent warnings on iteration variables
#							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
#							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
#							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
#							bug 402028 - [1.8][compiler] null analysis for reference expressions
#							bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
#							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
#							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
#							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
#							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
#							Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
#							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
#							Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
#							Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
#							Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
#							Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
#							Bug 430150 - [1.8][null] stricter checking against type variables
#							Bug 434600 - Incorrect null analysis error reporting on type parameters
#							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
#							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
#							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
#		Jesper S Moller <jesper@selskabet.org> - Contributions for
#							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
#							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
#							Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
#							Bug 419209 - [1.8] Repeating container annotations should be rejected in the presence of annotation it contains
#							Bug 527554 - [18.3] Compiler support for JEP 286 Local-Variable Type
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved to a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The nested type {0} cannot be referenced using its binary name
7 = The type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}
18 = The static member type {0}.{1} should be accessed directly
19 = Type mismatch: cannot convert from {0} to {1}
20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
25 = Cannot refer to the non-final local variable {0} defined in an enclosing scope
26 = The member interface {0} can only be defined inside a top-level class or interface or in a static context
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}
30 = The member annotation {0} can only be defined inside a top-level class or interface or in a static context
31 = The member enum {0} can only be defined inside a top-level class or interface or in a static context
32 = The member enum {0} must be defined inside a static member type
33 = The type {0} is hiding the type {1}
34 = {0} is not an annotation type

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
###[obsolete] 53 = An array of void is an invalid type for the variable {0}
54 = void[] is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate parameter {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment
59 = The parameter {0} should not be assigned
60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The value of the local variable {0} is not used
62 = The value of the parameter {0} is not used
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many parameters, parameter {0} is exceeding the limit of 255 words eligible for method parameters
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic parameters, emulated parameter {0} is exceeding the limit of 255 words eligible for method parameters
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {1}.{0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The value of the field {0}.{1} is not used
78 = The static field {0}.{1} should be accessed directly
79 = Unqualified access to the field {0}.{1} 
80 = The final field {0}.{1} cannot be assigned
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned
83 = {0} cannot be resolved to a variable
84 = This static method of interface {0} can only be accessed as {0}.{1}
85 = The value of the exception parameter {0} is not used

90 = The local variable {0} is hiding another local variable defined in an enclosing scope
91 = The local variable {0} is hiding a field from type {1}
92 = The field {0}.{1} is hiding another local variable defined in an enclosing scope
93 = The field {0}.{1} is hiding a field from type {2}
94 = The parameter {0} is hiding another local variable defined in an enclosing scope
95 = The parameter {0} is hiding a field from type {1}
96 = The serializable class {0} does not declare a static final serialVersionUID field of type long
97 = Lambda expression''s parameter {0} cannot redeclare another local variable defined in an enclosing scope. 
98 = Lambda expression''s local variable {0} cannot redeclare another local variable defined in an enclosing scope. 
99 = The type {0} from the descriptor computed for the target context is not visible here.  
100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The method {1}({2}) from the type {0} is never used locally
119 = The static method {1}({2}) from the type {0} should be accessed directly 
120 = The method {1}({2}) from the type {0} refers to the missing type {3}
121 = The method {1}({2}) from the type {0} can be declared as static
122 = The method {1}({2}) from the type {0} can potentially be declared as static
123 = Ambiguous method reference: both {1}({2}) and {3}({4}) from the type {0} are eligible
124 = The method {1}({2}) from the type {0} should be accessed in a static way 
125 = Incompatible parameter list for array constructor. Expected (int), but found ({1})
126 = Constructed array {0} cannot be assigned to {1} as required in the interface descriptor  
127 = The type {0} does not define {1}({2}) that is applicable here
128 = The type of {0}({1}) from the type {2} is {3}, this is incompatible with the descriptor''s return type: {4}
129 = The constructor {0}({1}) refers to the missing type {2}
130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
134 = The constructor {0}({1}) is never used locally
135 = Cannot refer to an instance field {0} while explicitly invoking a constructor
136 = Cannot refer to an instance method while explicitly invoking a constructor
137 = Recursive constructor invocation {0}({1})
138 = Cannot refer to 'this' nor 'super' while explicitly invoking a constructor
139 = Constructor call must be the first statement in a constructor
140 = Implicit super constructor {0}({1}) is undefined for default constructor. Must define an explicit constructor
141 = Implicit super constructor {0}({1}) is not visible for default constructor. Must define an explicit constructor
142 = Implicit super constructor {0}({1}) is ambiguous for default constructor. Must define an explicit constructor
143 = Implicit super constructor {0}({1}) is undefined. Must explicitly invoke another constructor
144 = Implicit super constructor {0}({1}) is not visible. Must explicitly invoke another constructor
145 = Implicit super constructor {0}({1}) is ambiguous. Must explicitly invoke another constructor
146 = Default constructor cannot handle exception type {0} thrown by implicit super constructor. Must define an explicit constructor
147 = Unhandled exception type {0} thrown by implicit super constructor


148 = The allocated object is never used
149 = Dead code
150 = The type of the expression must be an array type but it resolved to {0}
151 = Must explicitly convert the char[] to a String
152 = String constant is exceeding the limit of 65535 bytes of UTF8 encoding
153 = case expressions must be constant expressions
154 = The literal {1} of type {0} is out of range 
156 = Cannot cast from {0} to {1}
157 = Cannot instantiate the type {0}
158 = Cannot define dimension expressions when an array initializer is provided
159 = Variable must provide either dimension expressions or an array initializer
160 = The operator {0} is undefined for the argument type(s) {1}
161 = Unreachable code
162 = Cannot return from within an initializer
163 = Initializer does not complete normally
164 = Expression must return a value
165 = Unreachable catch block for {0}. Only more specific exceptions are thrown and they are handled by previous catch block(s).
166 = The default case is already defined
167 = Unreachable catch block for {0}. This exception is never thrown from the try statement body
168 = Unhandled exception type {0}
169 = Cannot switch on a value of type {0}. Only convertible int values or enum variables are permitted
170 = Duplicate case
171 = Duplicate label {0}
172 = break cannot be used outside of a loop or a switch
173 = continue cannot be used outside of a loop
174 = The label {0} is missing
175 = {0} is not a valid type''s argument for the synchronized statement
176 = null is not a valid argument for the synchronized statement
177 = Cannot throw null as an exception
178 = The assignment to variable {0} has no effect
179 = Possible accidental assignment in place of a comparison. A condition expression should not be reduced to an assignment
180 = Unnecessary semicolon
181 = Unnecessary cast from {0} to {1}
182 = Unnecessary cast from {0} to {1}. It is already compatible with the argument type {2}
183 = The expression of type {0} is already an instance of type {1}
184 = finally block does not complete normally
185 = The declared exception {3} is not actually thrown by the method {1}({2}) from type {0}
186 = The declared exception {2} is not actually thrown by the constructor {0}({1})
187 = Unreachable catch block for {0}. It is already handled by the catch block for {1}
188 = Empty control-flow statement
189 = Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally
190 = Read access to enclosing field {0}.{1} is emulated by a synthetic accessor method
191 = Write access to enclosing field {0}.{1} is emulated by a synthetic accessor method
192 = Access to enclosing method {1}({2}) from the type {0} is emulated by a synthetic accessor method
193 = Access to enclosing constructor {0}({1}) is emulated by a synthetic accessor method
194 = Switch case may be entered by falling through previous case. If intended, add a new comment //$FALL-THROUGH$ on the line above
195 = The method {1} is defined in an inherited type and an enclosing scope
196 = The field {0} is defined in an inherited type and an enclosing scope 
197 = The type {0} is defined in an inherited type and an enclosing scope
198 = Cannot allocate the member type {0} using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type
199 = The label {0} is never explicitly referenced
200 = Cannot use {0} in a static context
201 = Cannot make a static reference to the non-static method {1}({2}) from the type {0}
202 = Cannot specify an array dimension after an empty dimension
#203 = Invalid cast expression
204 = Syntax error on token "{0}", {1} expected
205 = Syntax error on token "{0}", no accurate correction available
206 = Invalid argument to operation ++/--
207 = Interfaces cannot have constructors
208 = Array constants can only be used in initializers
209 = Syntax error on keyword "{0}"; {1} expected
210 = Syntax error on keyword "{0}", no accurate correction available
211 = Comparing identical expressions

220 = Unmatched bracket
221 = The primitive type {0} of {1} does not have a field {2}
222 = Invalid expression as statement
223 = The left-hand side of an assignment must be a variable
224 = Missing semicolon
225 = Invalid parenthesized expression
226 = super reference is illegal in interface context

230 = Syntax error on token "{0}", {1} expected before this token
231 = Syntax error on token "{0}", {1} expected after this token
232 = Syntax error on token "{0}", delete this token
233 = Syntax error on tokens, delete these tokens
234 = Syntax error on tokens, they can be merged to form {0}
235 = Syntax error on token "{0}", invalid {1}
236 = Syntax error on token(s), misplaced construct(s)
237 = Syntax error on tokens, {0} expected instead
238 = Syntax error on tokens, no accurate correction available
239 = Syntax error, unexpected {0}
240 = Syntax error, insert "{0}" to complete {1}
241 = Syntax error, insert "{0}" to complete scope
242 = Syntax error, insert "{0}" to complete phrase

250 = Unexpected end of file
251 = Invalid hex literal number
252 = Invalid octal literal number
253 = Invalid character constant
254 = Invalid escape sequence (valid ones are  \\b  \\t  \\n  \\f  \\r  \\"  \\'  \\\\ )
255 = Invalid input
256 = Invalid unicode
257 = Invalid float literal number
258 = Null source string
259 = String literal is not properly closed by a double-quote
260 = Unexpected end of comment
261 = Non-externalized string literal; it should be followed by //$NON-NLS-<n>$
262 = Invalid digit (valid ones are 0..9)
263 = Invalid low surrogate: must be within 0xDC00 and 0xDFFF
264 = Invalid high surrogate: must be within 0xD800 and 0xDBFF
265 = Unnecessary $NON-NLS$ tag
266 = Invalid binary literal number (only '0' and '1' are expected)
267 = Binary literals can only be used with source level 1.7 or greater
268 = Underscores have to be located within digits
269 = Underscores can only be used with source level 1.7 or greater
271 = This lambda expression refers to the missing type {0}

280 = Discouraged access: {0}

300 = The interface {0} cannot define an initializer
301 = Duplicate modifier for the type {0}
302 = Illegal modifier for the class {0}; only public, abstract & final are permitted
303 = Illegal modifier for the interface {0}; only public & abstract are permitted
304 = Illegal modifier for the member class {0}; only public, protected, private, abstract, static & final are permitted
305 = Illegal modifier for the member interface {0}; only public, protected, private, abstract & static are permitted
306 = Illegal modifier for the local class {0}; only abstract or final is permitted
307 = Access restriction: {0}
308 = The class {0} can be either abstract or final, not both
309 = The interface member type {0} can only be public
310 = The member type {0} can only set one of public / protected / private
311 = The member type {0} cannot be declared static; static types can only be declared in static or top level types
312 = The type {0} cannot be the superclass of {1}; a superclass must be a class
313 = The type {1} cannot subclass the final class {0}
314 = Duplicate interface {0} for the type {1}
315 = The type {0} cannot be a superinterface of {1}; a superinterface must be an interface
316 = Cycle detected: the type {0} cannot extend/implement itself or one of its own member types
317 = Cycle detected: a cycle exists in the type hierarchy between {0} and {1}
318 = The nested type {0} cannot hide an enclosing type
319 = Duplicate nested type {0}
320 = No exception of type {0} can be thrown; an exception type must be a subclass of Throwable
321 = The package {0} collides with a type
322 = The type {1} collides with a package
323 = The type {1} is already defined
324 = The type {0} cannot be resolved. It is indirectly referenced from required .class files
325 = The public type {1} must be defined in its own file
###[obsolete] 326 = A package must be specified in {0} or a default package created
327 = The hierarchy of the type {0} is inconsistent
328 = The declared package "{1}" does not match the expected package "{0}"
329 = The type java.lang.Object cannot have a superclass or superinterfaces
330 = The type java.lang.Object must be a class
331 = Redundant superinterface {0} for the type {1}, already defined by {2}
332 = The type {0} should also implement hashCode() since it overrides Object.equals()
333 = The type {0} must be an abstract class to define abstract methods

###[obsolete] 330 = {0} cannot be resolved or is not a valid superclass
###[obsolete] 331 = Superclass {0} is not visible
###[obsolete] 332 = Superclass {0} is ambiguous
###[obsolete] 333 = Superclass {0} cannot be referenced using its binary name
###[obsolete] 334 = Superclass {0} is defined in an inherited type and an enclosing scope
###[obsolete] 335 = {0} cannot be resolved or is not a valid superinterface
###[obsolete] 336 = Superinterface {0} is not visible
###[obsolete] 337 = Superinterface {0} is ambiguous
###[obsolete] 338 = Superinterface {0} cannot be referenced using its binary name
###[obsolete] 339 = Superinterface {0} is defined in an inherited type and an enclosing scope

340 = Duplicate field {0}.{1}
341 = Duplicate modifier for the field {0}
342 = Illegal modifier for the field {0}; only public, protected, private, static, final, transient & volatile are permitted
343 = Illegal modifier for the interface field {0}.{1}; only public, static & final are permitted
344 = The field {0} can only set one of public / protected / private
345 = The field {0} can be either final or volatile, not both
346 = The field {0} cannot be declared static in a non-static inner type, unless initialized with a constant expression

###[obsolete] 350 = {2} cannot be resolved (or is not a valid type) for the field {1}.{0}
###[obsolete] 351 = The type {2} is not visible for the field {1}.{0}
###[obsolete] 352 = The type {2} is ambiguous for the field {1}.{0}
###[obsolete] 353 = The field type {2} cannot be referenced using its binary name
###[obsolete] 354 = The field type {2} is defined in an inherited type and an enclosing scope

355 = Duplicate method {0}({2}) in type {1}
356 = Illegal modifier for parameter {0}; only final is permitted
357 = Duplicate modifier for the method {1} in type {0}
358 = Illegal modifier for the method {0}; only public, protected, private, abstract, static, final, synchronized, native & strictfp are permitted
359 = Illegal modifier for the interface method {0}; only public & abstract are permitted
360 = The method {1} in type {0} can only set one of public / protected / private
361 = The method {1} cannot be declared static; static methods can only be declared in a static or top level type
362 = The abstract method {1} in type {0} can only set a visibility modifier, one of public or protected
363 = The abstract method {1} in type {0} can only be defined by an abstract class
364 = void is an invalid type for the parameter {1} of a method
###[obsolete] 365 = An array of void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 366 = An array of void is an invalid return type for the method {0}
367 = The native method {1} cannot also be declared strictfp
368 = Duplicate modifier for parameter {0}
369 = Illegal modifier for the constructor in type {0}; only public, protected & private are permitted

###[obsolete] 370 = {2} cannot be resolved (or is not a valid type) for the parameter {1} of the method {0}
###[obsolete] 371 = The type {2} is not visible for the parameter {1} of the method {0}
###[obsolete] 372 = The type {2} is ambiguous for the parameter {1} of the method {0}
###[obsolete] 373 = The parameter type {2} cannot be referenced using its binary name
###[obsolete] 374 = The parameter type {2} is defined in an inherited type and an enclosing scope
###[obsolete] 375 = {1} cannot be resolved (or is not an exception type) for the method {0}
###[obsolete] 376 = The exception type {1} is not visible for the method {0}
###[obsolete] 377 = The exception type {1} is ambiguous for the method {0}
###[obsolete] 378 = The exception type {1} cannot be referenced using its binary name
###[obsolete] 379 = The exception type {1} is defined in an inherited type and an enclosing scope
###[obsolete] 380 = {1} cannot be resolved (or is not a valid return type) for the method {0}
###[obsolete] 381 = The return type {1} is not visible for the method {0}
###[obsolete] 382 = The return type {1} is ambiguous for the method {0}
###[obsolete] 383 = The return type {1} cannot be referenced using its binary name
###[obsolete] 384 = The return type {1} is defined in an inherited type and an enclosing scope

385 = The import {0} conflicts with a type defined in the same file
386 = The import {0} collides with another import statement
387 = Only a type can be imported. {0} resolves to a package
388 = The import {0} is never used
390 = The import {0} cannot be resolved

###[obsolete] 391 = The imported type {0} is not visible
###[obsolete] 392 = The imported type {0} is ambiguous
###[obsolete] 393 = The imported type {0} cannot be referenced using its binary name
###[obsolete] 394 = The imported type {0} is defined in an inherited type and an enclosing scope

391 = The static import {0} must be a field or member type

395 = Duplicate modifier for the variable {0}
396 = Illegal modifier for the variable {0}; only final is permitted
###[obsolete] 397 = Redundant null check: The variable {0} cannot be null at this location
###[obsolete] 398 = Null pointer access: The variable {0} can only be null at this location
###[obsolete] 399 = Potential null pointer access: The variable {0} may be null at this location
	
400 = The type {3} must implement the inherited abstract method {2}.{0}({1})
401 = Cannot override the final method from {0}
402 = Exception {0} is not compatible with throws clause in {1}
403 = Exception {0} in throws clause of {1} is not compatible with {2}
404 = The return type is incompatible with {0}
405 = The inherited method {0} cannot hide the public abstract method in {1}
406 = This instance method cannot override the static method from {0}
407 = This static method cannot hide the instance method from {0}
408 = The static method {0} conflicts with the abstract method in {1}
409 = Cannot reduce the visibility of the inherited method from {0}
410 = The method {0} does not override the inherited method from {1} since it is private to a different package
411 = This class must implement the inherited abstract method {1}, but cannot override it since it is not visible from {0}. Either make the type abstract or make the inherited method visible
412 = The method {0} overrides a deprecated method from {1}
413 = The return type is incompatible with {0}, thus this interface cannot be implemented
414 = Exception {0} is not compatible with throws clause in {1}, thus this interface cannot be implemented
415 = The variable argument type {0} of the method {1} must be the last parameter
416 = The method {0} is overriding a method without making a super invocation
417 = The method {0}.{1}({2}) is overriding a synchronized method without being synchronized
418 = The type {3} must implement the inherited abstract method {2}.{0}({1}) to override {6}.{4}({5})
419 = The return types are incompatible for the inherited methods {0}

420 = Code snippet support cannot find the class {0}
421 = Code snippet support cannot find the method {0}.{1}({2}) 
422 = super cannot be used in the code snippet code

430 = Too many constants, the constant pool for {0} would exceed 65536 entries
431 = The type generates a string that requires more than 65535 bytes to encode in Utf8 format in the constant pool

432 = Too many fields for type {0}. Maximum is 65535
433 = Too many methods for type {0}. Maximum is 65535
434 = The synthetic method created to access {0}({1}) of type {2} has too many parameters

440 = 'assert' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on
441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
442 = Enum constants cannot be surrounded by parenthesis
443 = '_' should not be used as an identifier, since it is a reserved keyword from source level 1.8 on
444 = The uninterned types {0} and {1} should not be compared using ==/!= operators.

450 = {0}{1}

451 = Null pointer access: The variable {0} can only be null at this location
452 = Potential null pointer access: The variable {0} may be null at this location
453 = Redundant null check: The variable {0} can only be null at this location
454 = Null comparison always yields false: The variable {0} can only be null at this location
455 = Redundant assignment: The variable {0} can only be null at this location
456 = instanceof always yields false: The variable {0} can only be null at this location
457 = Redundant null check: The variable {0} cannot be null at this location
458 = Null comparison always yields false: The variable {0} cannot be null at this location
459 = Potential null pointer access: This expression of type {0} may be null but requires auto-unboxing
461 = Null pointer access: This expression of type {0} is null but requires auto-unboxing
460 = Empty block should be documented

### DOC
462 = Invalid URL reference. Double quote the reference or use the href syntax
463 = Description expected after this reference
464 = Unexpected duplicated tag @{0}
465 = ''{0}'' visibility for malformed doc comments hides this ''{1}'' reference
466 = Invalid member type qualification
467 = Missing identifier
468 = Cannot make a static reference to the non-static type variable {0}
469 = Invalid param tag type parameter name
470 = Unexpected tag
471 = Missing tag for parameter {0}
472 = Missing parameter name
473 = Duplicate tag for parameter
474 = Parameter {0} is not declared
475 = Missing tag for return type
476 = Duplicate tag for return type
477 = Missing tag for declared exception {0}
478 = Missing class name
479 = Invalid class name
480 = Duplicate tag for thrown exception
481 = Exception {0} is not declared
482 = Missing reference
483 = Invalid reference
484 = Malformed link reference
485 = Invalid parameters declaration
486 = Missing comment for {0} declaration
487 = Invalid tag
488 = {0} cannot be resolved or is not a field
489 = The field {0} is not visible
490 = The field {0} is ambiguous
491 = The field {0}.{1} is deprecated
492 = The constructor {0}({1}) is undefined
493 = The constructor {0}({1}) is not visible
494 = The constructor {0}({1}) is ambiguous
495 = The constructor {0}({1}) is deprecated
496 = The method {1}({2}) is undefined for the type {0}
497 = The method {1}({2}) from the type {0} is not visible
498 = The method {1}({2}) is ambiguous for the type {0}
499 = The method {1}({2}) from the type {0} is deprecated
500 = Cannot invoke {1}({2}) on the primitive type {0}
501 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
502 = Cannot invoke {1}({2}) on the array type {0}
503 = {0} cannot be resolved to a type
504 = The type {0} is not visible
505 = The type {0} is ambiguous
506 = The type {0} is deprecated
507 = The nested type {0} cannot be referenced using its binary name
508 = The method {1} is defined in an inherited type and an enclosing scope
509 = The field {0} is defined in an inherited type and an enclosing scope 
510 = The type {0} is defined in an inherited type and an enclosing scope
511 = {0} is an ambiguous method reference or is not a field
512 = Missing closing brace for inline tag
513 = Malformed reference (missing end space separator)
514 = Javadoc: 
515 = Missing #: "{0}"
516 = Description expected after @{0}
517 = Only static field reference is allowed for @value tag
518 = Unexpected text
519 = Invalid param tag name

### GENERICS
520 = Duplicate type parameter {0}
521 = Cannot refer to the type parameter {0} as a supertype
522 = Cannot make a static reference to the non-static type {0}
523 = The type java.lang.Object cannot be declared as a generic
524 = The type {0} is not generic; it cannot be parameterized with arguments <{1}>
525 = Incorrect number of arguments for type {0}; it cannot be parameterized with arguments <{1}>
526 = Bound mismatch: The type {0} is not a valid substitute for the bounded parameter <{2} extends {3}> of the type {1}
527 = Erasure of method {0}({2}) is the same as another method in type {1}
528 = Illegal forward reference to type parameter {0}
529 = The type {0} is not an interface; it cannot be specified as a bounded parameter
530 = Type safety: The constructor {0}({1}) belongs to the raw type {0}. References to generic type {2} should be parameterized
531 = Type safety: The method {0}({1}) belongs to the raw type {2}. References to generic type {3} should be parameterized
532 = Type safety: The expression of type {0} needs unchecked conversion to conform to {1}
533 = Cannot use the type parameter {0} in a catch block
534 = Cannot use the parameterized type {0} either in catch block or throws clause
535 = Cannot create a generic array of {0}
536 = Type safety: The field {1} from the raw type {2} is assigned a value of type {0}. References to generic type {3} should be parameterized
537 = The type parameter {0} should not be bounded by the final type {1}. Final types cannot be further extended
538 = Inconsistent classfile encountered: The undefined type parameter {0} is referenced from within {1}
539 = The interface {2} cannot be implemented more than once with different arguments: {0} and {1}
540 = Bound mismatch: The constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
541 = Bound mismatch: The method {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
542 = Bound mismatch: Cannot assign expression of type {0} to wildcard type {1}. The wildcard type has no lower bound, and may actually be more restrictive than expression type
543 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
544 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
545 = Type safety: Unchecked cast from {0} to {1}
546 = Cannot perform instanceof check against parameterized type {0}. Use the form {1} instead since further generic type information will be erased at runtime
547 = Cannot perform instanceof check against type parameter {0}. Use its erasure {1} instead since further generic type information will be erased at runtime
548 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
549 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
550 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
551 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
552 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
553 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
554 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
555 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
556 = The type {1} cannot extend or implement {0}. A supertype may not specify any wildcard
557 = The generic class {0} may not subclass java.lang.Throwable
558 = Illegal class literal for the type parameter {0}
559 = Type safety: The return type {0} for {1}({2}) from the type {3} needs unchecked conversion to conform to {4} from the type {5}
560 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not override it
561 = The member type {0}<{1}> must be qualified with a parameterized type, since it is not static
562 = The member type {0} must be parameterized, since it is qualified with a parameterized type
563 = The member type {0} cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type {1}
###[obsolete] 564 = Bound conflict: {0} is inherited with conflicting arguments
565 = Duplicate methods named {0} with the parameters ({2}) and ({3}) are defined by the type {1}
566 = Cannot allocate the member type {0} using a parameterized compound name; use its simple name and an enclosing instance of type {1}
567 = Duplicate bound {0}
568 = The array type {0} cannot be used as a type parameter bound
569 = Type safety: Unchecked invocation {0}({3}) of the generic constructor {0}({1}) of type {2}
570 = Type safety: Unchecked invocation {0}({3}) of the generic method {0}({1}) of type {2}
571 = The type parameter {0} is hiding the type {1}
572 = {0} is a raw type. References to generic type {1} should be parameterized
573 = Cannot specify any additional bound {0} when first bound is a type parameter
574 = Type safety: A generic array of {0} is created for a varargs parameter
575 = Illegal qualified access from the type parameter {0}
576 = The nested type {0} is hiding the type parameter {1} of type {2}
577 = The nested type {0} is hiding the type parameter {1} of the generic method {2}({3}) of type {4}
578 = Wildcard is not allowed at this location
579 = Unused type arguments for the non generic method {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>
583 = Duplicate methods named {0} with the parameters ({1}) and ({2}) are inherited from the types {3} and {4}
584 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not hide it
586 = Type arguments are not allowed here

### FOREACH
580 = Type mismatch: cannot convert from element type {0} to {1}
581 = Can only iterate over an array or an instance of java.lang.Iterable
582 = Can only iterate over an array or an instance of java.util.Collection
585 = Type safety: Elements of type {0} need unchecked conversion to conform to {1}

### SOURCE LEVEL
590 = Syntax error, type parameters are only available if source level is 1.5 or greater
591 = Syntax error, static imports are only available if source level is 1.5 or greater
592 = Syntax error, 'for each' statements are only available if source level is 1.5 or greater
593 = Syntax error, parameterized types are only available if source level is 1.5 or greater
594 = Syntax error, enum declarations are only available if source level is 1.5 or greater
595 = Syntax error, varargs are only available if source level is 1.5 or greater
596 = Syntax error, annotations are only available if source level is 1.5 or greater
597 = Syntax error, annotation declarations are only available if source level is 1.5 or greater
598 = Syntax error, annotation declaration cannot have type parameters
599 = Syntax error, enum declaration cannot have type parameters

### ANNOTATIONS
600 = Illegal modifier for the annotation attribute {0}.{1}; only public & abstract are permitted
601 = Extended dimensions are illegal in an annotation attribute declaration
602 = Package annotations must be in file package-info.java
603 = Illegal modifier for the annotation type {0}; only public & abstract are permitted
604 = Illegal modifier for the member annotation type {0}; only public, protected, private, abstract & static are permitted
605 = Invalid type {0} for the annotation attribute {2}.{1}; only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof
606 = Cycle detected: the annotation type {0} cannot contain attributes of the annotation type itself
607 = Cycle detected: a cycle exists between annotation attributes of {0} and {1}
608 = Duplicate annotation @{0}. Repeated annotations are allowed only at source level 1.8 or above
609 = The annotation @{0} must define the attribute {1}
610 = Duplicate attribute {0} in annotation @{1}
611 = The attribute {0} is undefined for the annotation type {1}
612 = The value for annotation attribute {0}.{1} must be a class literal
613 = The value for annotation attribute {0}.{1} must be a constant expression
###[obsolete] 614 = The annotation field {0}.{1} must be initialized with a constant expression
615 = Illegal modifier for the annotation field {0}.{1}; only public, static & final are permitted
616 = The annotation type {0} cannot override the method {1}.{2}({3})
617 = Annotation attributes cannot have parameters
618 = Annotation attributes cannot be generic
619 = Annotation type declaration cannot have an explicit superclass
620 = Annotation type declaration cannot have explicit superinterfaces
621 = Duplicate element {0} specified in annotation @{1}
622 = The annotation @{0} is disallowed for this location
623 = The method {0}({1}) of type {2} must override a superclass method
624 = Annotation type declaration cannot have a constructor
625 = The value for annotation attribute {0}.{1} must be some @{2} annotation 
626 = The annotation type {0} should not be used as a superinterface for {1}
627 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superclass method
628 = The deprecated field {0}.{1} should be annotated with @Deprecated
629 = The deprecated method {0}({1}) of type {2} should be annotated with @Deprecated
630 = The deprecated type {0} should be annotated with @Deprecated
631 = Unsupported @SuppressWarnings("{0}")
632 = The value for annotation attribute {0}.{1} must be an array initializer
633 = The value for annotation attribute {0}.{1} must be an enum constant expression
634 = The method {0}({1}) of type {2} must override or implement a supertype method
635 = Unnecessary @SuppressWarnings("{0}")
636 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superinterface method
637 = Syntax error, type annotations are available only when source level is at least 1.8
638 = Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors
639 = Syntax error, type annotations are illegal here
640 = Type annotations are not allowed on type names used to access static members
641 = Type annotation is illegal for a method that returns void
642 = Only the first formal parameter may be declared explicitly as 'this'
643 = Explicit declaration of 'this' parameter is allowed only at source level 1.8 or above
644 = Default methods are allowed only at source level 1.8 or above
645 = Lambda expressions are allowed only at source level 1.8 or above
646 = Method references are allowed only at source level 1.8 or above
647 = Constructor references are allowed only at source level 1.8 or above
648 = Lambda expressions cannot declare a this parameter
649 = Annotation types that do not specify explicit target element types cannot be applied here
650 = The declared type of the explicit ''this'' parameter is expected to be {0}
651 = The explicit ''this'' parameter is expected to be qualified with {0}
652 = The explicit 'this' parameter for a method cannot have a qualifying name
653 = The target type of this expression must be a functional interface
654 = The variable argument type {0} of the lambda expression must be the last parameter
655 = The target type of this expression is not a well formed parameterized type due to bound(s) mismatch
656 = Lambda expression''s signature does not match the signature of the functional interface method {0}
657 = Lambda expression''s parameter {0} is expected to be of type {1}
658 = Incompatible type specified for lambda expression''s parameter {0}
659 = Illegal lambda expression: Method {0} of type {1} is generic 
### MORE GENERICS
660 = Unused type arguments for the non generic constructor {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>
661 = Unused type parameter {0}

### MORE TYPE RELATED
662 = Illegal attempt to create arrays of union types
663 = Local variable {0} defined in an enclosing scope must be final or effectively final
664 = Invalid ''@FunctionalInterface'' annotation; {0} is not a functional interface
665 = The constructed object of type {0} is incompatible with the descriptor''s return type: {1}
666 = Syntax error, type annotations are illegal here
667 = Super method references to interface default methods are allowed only at source level 1.8 or above
668 = References to interface static methods are allowed only at source level 1.8 or above
669 = Field {0} must be final

### NULL ANALYSIS FOR OTHER EXPRESSIONS
670 = Null comparison always yields false: this expression cannot be null
671 = Redundant null check: this expression cannot be null
672 = Null pointer access: This expression can only be null
673 = Potential null pointer access: This expression may be null

### CORRUPTED BINARIES
700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}

### CORRUPTED SOURCES
701 = Cannot read the source from {0}; either the file uses a different encoding than {1} or it is corrupted
702 = Cannot read the source from {0} due to internal exception {1}

### AUTOBOXING
720 = The expression of type {0} is boxed into {1}
721 = The expression of type {0} is unboxed into {1}

### ENUMS
750 = Illegal modifier for the enum {0}; only public is permitted
751 = Illegal modifier for the enum constant {0}; no modifier is allowed
###[obsolete] 752 = Illegal modifier for the local enum {0}; only abstract is permitted
753 = Illegal modifier for the member enum {0}; only public, protected, private & static are permitted
754 = The enum {1} already defines the method {0}({2}) implicitly
755 = The qualified case label {0}.{1} must be replaced with the unqualified enum constant {1}
756 = The type {1} may not subclass {0} explicitly
757 = Cannot invoke super constructor from enum constructor {0}({1})
758 = The enum {2} can only define the abstract method {0}({1}) if it also defines enum constants with corresponding implementations
759 = The field {0}.{1} cannot be referenced from an enum case label; only enum constants can be used in enum switch
760 = Illegal modifier for the enum constructor; only private is permitted.
761 = The enum constant {1} needs a corresponding case label in this enum switch on {0}
762 = Cannot refer to the static enum field {0}.{1} within an initializer
763 = The enum constant {2} must implement the abstract method {0}({1})
764 = The enum constant {0} cannot define abstract methods
765 = The method {1} cannot be abstract in the enum constant {0}
766 = The switch over the enum type {0} should have a default case
767 = The switch statement should have a default case
768 = The enum constant {1} should have a corresponding case label in this enum switch on {0}. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the ''default:''
769 = The local variable {0} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
770 = The blank final field {0} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
771 = This method must return a result of type {0}. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem

### VARARGS
800 = Extended dimensions are illegal for a variable argument
801 = Type {0} of the last argument to method {2}({3}) doesn''t exactly match the vararg parameter type. Cast to {1} to confirm the non-varargs invocation, or pass individual arguments of type {5} for a varargs invocation.
802 = Type {0} of the last argument to constructor {2}({3}) doesn''t exactly match the vararg parameter type. Cast to {1} to confirm the non-varargs invocation, or pass individual arguments of type {4} for a varargs invocation.
803 = Varargs methods should only override or be overridden by other varargs methods unlike {2}.{0}({1}) and {4}.{0}({3})
804 = @SafeVarargs annotation cannot be applied to fixed arity method {0}
805 = @SafeVarargs annotation cannot be applied to non-final instance method {0}
806 = Type safety: Potential heap pollution via varargs parameter {0}
807 = The method {0}({1}) of type {2} is not applicable as the formal varargs element type {3} is not accessible here
808 = The constructor {0}({1}) of type {2} is not applicable as the formal varargs element type {3} is not accessible here
809 = The method {0}({1}) of type {2} cannot be invoked as it is overridden by an inapplicable method

### GENERIC JAVADOC
850 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
851 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
852 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
853 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
854 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
855 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
856 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
857 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
858 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
859 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>

### Java 7
870 = The parameter {0} of a multi-catch block cannot be assigned
871 = The resource type {0} does not implement java.lang.AutoCloseable
872 = The resource {0} of a try-with-resources statement cannot be assigned
873 = The exception {0} is already caught by the alternative {1}
874 = Resource specification not allowed here for source level below 1.7
875 = Multi-catch parameters are not allowed for source level below 1.7
876 = Invocation of polymorphic methods not allowed for source level below 1.7
877 = Cannot switch on a value of type {0}. Only convertible int values, strings or enum variables are permitted
878 = Cannot infer type arguments for {0}
879 = Explicit type arguments cannot be used with '<>' in an allocation expression
880 = '<>' cannot be used with anonymous classes
881 = Cannot switch on a value of type String for source level below 1.7. Only convertible int values or enum variables are permitted
882 = Unhandled exception type {0} thrown by automatic close() invocation on {1}
883 = '<>' operator is not allowed for source level below 1.7
884 = Redundant specification of type arguments <{0}>
885 = Potential resource leak: ''{0}'' may not be closed
886 = Potential resource leak: ''{0}'' may not be closed at this location
887 = Resource leak: ''{0}'' is never closed
888 = Resource leak: ''{0}'' is not closed at this location
889 = Resource ''{0}'' should be managed by try-with-resource
890 = Cannot switch on an enum value for source level below 1.5. Only convertible int values are permitted

#### Java 8
891 = Additional bounds are not allowed in cast operator at source levels below 1.8
892 = Base types are not allowed in intersection cast operator
893 = Arrays are not allowed in intersection cast operator
894 = Duplicate type in intersection cast operator
#[obsolete] 895 = The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional
896 = Static methods are allowed in interfaces only at source level 1.8 or above

897 = Duplicate annotation of non-repeatable type @{0}. Only annotation types marked @Repeatable can be used multiple times at one target.
898 = The annotation @{0} cannot be repeated at this location since its container annotation type @{1} is disallowed at this location
899 = The repeatable annotation @{0} may not be repeated where its container annotation type @{1} is also used directly
902 = The value method in the container annotation type @{0} must be of type {1}[] but is {2}
903 = The container annotation type @{0} must declare a member value()
904 = The container annotation type @{0} must declare a default value for the annotation attribute ''{1}''
905 = Retention ''{1}'' of @{0} is longer than the retention of its container annotation type @{2}, which is ''{3}''
906 = The container annotation type @{1} is allowed at targets where the repeatable annotation type @{0} is not: {2}
907 = The repeatable annotation type @{0} is marked @Documented, but its container annotation type @{1} is not
908 = The repeatable annotation type @{0} is marked @Inherited, but its container annotation type @{1} is not
909 = The repeatable annotation @{0} may not be present where its container annotation type @{1} is repeated

### NULL ANNOTATIONS
910 = Null type mismatch: required ''{0}'' but the provided value is null
911 = Null type mismatch: required ''{0}'' but the provided value is inferred as @{1}
912 = Null type safety: The expression of type ''{0}'' needs unchecked conversion to conform to ''{1}''
913 = A default nullness annotation has not been specified for the package {0}
914 = The return type is incompatible with ''{1}'' returned from {0} (mismatching null constraints)
915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
917 = Missing non-null annotation: inherited method from {0} specifies this parameter as @{1}
918 = Missing nullable annotation: inherited method from {0} specifies this parameter as @{1}
919 = Potential null pointer access: The method {0} may return null
920 = Redundant null check: The method {0} cannot return null
921 = The method {0}{1}({2}) from {3} cannot implement the corresponding method from {4} due to incompatible nullness constraints
922 = The nullness annotation is redundant with a default that applies to this location
923 = The nullness annotation @{0} is not applicable for the primitive type {1}
924 = Potential null pointer access: The field {0} is specified as @{1}
925 = Nullness default is redundant with the global default
926 = Nullness default is redundant with a default specified for the enclosing package {0}
927 = Nullness default is redundant with a default specified for the enclosing type {0}
928 = Nullness default is redundant with a default specified for the enclosing method {0}
929 = Contradictory null specification; only one of @{0} and @{1} can be specified at any location
930 = A default nullness annotation has not been specified for the type {0}
931 = Redundant null check: The variable {0} is specified as @{1}
932 = Null comparison always yields false: The variable {0} is specified as @{1}
933 = Null type mismatch: required ''{0}'' but the provided value is specified as @{1}
934 = The @{0} field {1} may not have been initialized
935 = The @{0} field {1} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
936 = Null comparison always yields false: The method {0} cannot return null
937 = Redundant null check: The field {0} is specified as @{1}
938 = Null comparison always yields false: The field {0} is specified as @{1}
939 = The default ''@{0}'' conflicts with the inherited ''@{1}'' annotation in the overridden method from {2} 
940 = Conflict between inherited null annotations ''@{0}'' declared in {1} versus ''@{2}'' declared in {3} 
941 = Redundant null check: The field {0} cannot be null at this location (ignoring concurrency)
942 = Null comparison always yields false: The field {0} cannot be null at this location (ignoring concurrency)

951 = Potential null pointer access: array element may be null
952 = Potential null pointer access: this expression has a ''@{0}'' type
953 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}''
954 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}'', corresponding supertype is ''{2}''
955 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}''
956 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}'', corresponding supertype is ''{2}''
957 = Null type mismatch at parameter {0}: required ''{1}'' but provided ''{2}'' via method descriptor {3}
958 = Null type safety: parameter {0} provided via method descriptor {3} needs unchecked conversion to conform to ''{1}''
959 = Null type mismatch at method return type: Method descriptor {0} promises ''{1}'' but referenced method provides ''{2}''
960 = Null type safety at method return type: Method descriptor {0} promises ''{1}'' but referenced method provides ''{2}''
961 = Redundant null check: comparing ''{0}'' against null
962 = The nullness annotation ''{0}'' is not applicable at this location
963 = Nullness annotations are not applicable at this location 
964 = Null constraint mismatch: The type ''{1}'' is not a valid substitute for the type parameter ''{0}''
965 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
966 = Contradictory null annotations: method was inferred as ''{2} {3}({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
967 = Null type safety: Unchecked cast from {0} to {1}
#968 temporary warning has been removed
969 = Null type mismatch (type annotations): ''null'' is not compatible to the free type variable ''{0}''
970 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}'', where ''{0}'' is a free type variable
971 = The explicit type bound 'Object' is not affected by the nullness default for DefaultLocation.TYPE_BOUND.
972 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as ''{2}'' (mismatching null constraints)
973 = Contradictory null annotations: function type was inferred as ''{2} ({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
974 = The return type is incompatible with the free type variable ''{1}'' returned from {0} (mismatching null constraints)
975 = Cannot redefine null constraints of type variable ''{0}'' declared in ''{1}''
976 = Potential null pointer access: this expression has type ''{0}'', a free type variable that may represent a ''@{1}'' type
977 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type
978 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
979 = Null type safety: required ''@{0}'' but this expression has type ''{1}'', a free type variable that may represent a ''@{2}'' type
980 = Unsafe interpretation of method return type as ''@{0}'' based on the receiver type ''{1}''. Type ''{2}'' doesn''t seem to be designed with null type annotations in mind
981 = Unsafe interpretation of method return type as ''@{0}'' based on substitution ''{1}={2}''. Declaring type ''{3}'' doesn''t seem to be designed with null type annotations in mind


# Java 8
1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
1002 = Syntax error, modifiers are not allowed here
1003 = Explicit type arguments cannot be specified in raw constructor reference expression

# Default methods:
# variant of 359: 
1050 = Illegal modifier for the interface method {0}; only public, abstract, default, static and strictfp are permitted
1051 = A default method cannot override a method from java.lang.Object 
1052 = The default method {0} inherited from {1} conflicts with another method inherited from {2}
1053 = Duplicate default methods named {0} with the parameters ({1}) and ({2}) are inherited from the types {3} and {4}
1054 = Illegal reference to super type {0}, cannot bypass the more specific direct super type {1}
1055 = Illegal reference to super method {0} from type {1}, cannot bypass the more specific override from type {2}
1056 = Illegal combination of modifiers for the interface method {0}; only one of abstract, default, or static permitted
1057 = strictfp is not permitted for abstract interface method {0}
1058 = Default methods are allowed only in interfaces.
1059 = Cannot infer type argument(s) for <{0}> {1}
1060 = Illegally placed annotation: type annotations must directly precede the simple name of the type they are meant to affect (or the [] for arrays)
1061 = The nullness annotation ''{0}'' is not applicable at this location, it must be placed directly before the nested type name.
1062 = Nullness default is redundant with a default specified for the variable {0}
1063 = Nullness default is redundant with a default specified for the field {0}

1070 = Illegal combination of modifiers for the private interface method {0}; additionally only one of static and strictfp is permitted
1071 = Illegal modifier for the interface method {0}; only public, private, abstract, default, static and strictfp are permitted

1100 = Problem detected during type inference: {0}
#1101 is already used up but deprecated
1102 = At least one of the problems in category ''{0}'' is not analysed due to a compiler option being ignored

# more programming problems:
1200 = Unlikely argument type {0} for {1} on a {2}
1201 = Unlikely argument type for equals(): {0} seems to be unrelated to {2}

### Autoclosable try
1251 = Duplicate resource reference {0}

# Java9 - Module declaration related
1300 = {0} cannot be resolved to a module
1301 = Duplicate requires entry: {0}
1302 = Duplicate exports entry: {0}
1303 = Duplicate uses entry: {0}
1304 = Duplicate service entry: {0}
1305 = Cycle exists in module dependencies, Module {0} requires itself via {1}
1306 = Invalid service implementation, the type {0} is abstract
1307 = The service implementation {0} must define a public static provider method or a no-arg constructor
1308 = The no-arg constructor of service implementation {0} is not public
1309 = Invalid service implementation, the type {0} is an inner class
1310 = Service implementation {0} is not defined in the module with the provides directive
1311 = The package {0} does not exist or is empty
1312 = Type {0} inferred for {1}, is not valid for an anonymous class with ''<>''
1313 = Duplicate opens entry: {0}
1314 = Duplicate module name: {0}
1315 = opens statement is not allowed, as module {0} is declared open
1316 = Invalid service interface {0}, must be a class, interface or annotation type
1317 = Invalid service implementation {0}, must be a public class or interface type
1318 = Illegal modifier for module {0}; only open is permitted

#### Java 9
1351 = Variable resource not allowed here for source level below 9

# Java 9 - advanced deprecation
1400 = The type {0} has been deprecated and marked for removal
1401 = The method {1}({2}) from the type {0} has been deprecated and marked for removal
1402 = The constructor {0}({1}) has been deprecated and marked for removal
1403 = The field {0}.{1} has been deprecated and marked for removal
1404 = The method {0} overrides a method from {1} that has been deprecated and marked for removal

1405 = The type {0} is deprecated since version {1}
1406 = The method {1}({2}) from the type {0} is deprecated since version {3}
1407 = The constructor {0}({1}) is deprecated since version {2}
1408 = The field {0}.{1} is deprecated since version {2}
1409 = The method {0} overrides a method from {1} that is deprecated since version {2}

1410 = The type {0} has been deprecated since version {1} and marked for removal
1411 = The method {1}({2}) from the type {0} has been deprecated since version {3} and marked for removal
1412 = The constructor {0}({1}) has been deprecated since version {2} and marked for removal
1413 = The field {0}.{1} has been deprecated since version {2} and marked for removal
1414 = The method {0} overrides a method from {1} that has been deprecated since version {2} and marked for removal

1450 = The type {0} is not accessible
1451 = The field {1}.{0} is not accessible
1452 = The method {1}({2}) from the type {0} is not accessible
1453 = The constructor {0}({1}) is not accessible
1454 = The package {0} is not accessible
1455 = The package {0} is accessible from more than one module: {1}
1456 = The package {0} conflicts with a package accessible from another module: {1}
1457 = The type {0} is not accessible to clients that require this module
1458 = The type {0} is not exported from this module
1459 = The type {0} from module {1} may not be accessible to clients due to missing ''requires transitive''
1460 = Must declare a named package because this compilation unit is associated to the named module ''{0}''

# Local-Variable Type Inference
1500 = 'var' is not allowed in a compound declaration
1501 = 'var' is not allowed as an element type of an array
1502 = Declaration using 'var' may not contain references to itself
1503 = Cannot use 'var' on variable without initializer
1504 = Cannot infer type for local variable initialized to 'null'
1505 = Variable initializer is 'void' -- cannot infer variable type
1506 = Array initializer needs an explicit target-type
1507 = Lambda expression needs an explicit target-type
1508 = Method reference needs an explicit target-type
1509 = 'var' is not a valid type name
1510 = 'var' should not be used as an type name, since it is a reserved word from source level 10 on
1511 = 'var' is not allowed here

### ELABORATIONS
## Access restrictions
78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
78593 = The type ''{1}'' is not API (restriction on required project ''{0}'')
78594 = The type ''{1}'' is not API (restriction on required library ''{0}'')
78596 = The field ''{2}.{1}'' is not API (restriction on classpath entry ''{0}'')
78597 = The field ''{2}.{1}'' is not API (restriction on required project ''{0}'')
78598 = The field ''{2}.{1}'' is not API (restriction on required library ''{0}'')
78600 = The constructor ''{1}'' is not API (restriction on classpath entry ''{0}'')
78601 = The constructor ''{1}'' is not API (restriction on required project ''{0}'')
78602 = The constructor ''{1}'' is not API (restriction on required library ''{0}'')
78604 = The method ''{2}.{1}'' is not API (restriction on classpath entry ''{0}'')
78606 = The method ''{2}.{1}'' is not API (restriction on required library ''{0}'')
78605 = The method ''{2}.{1}'' is not API (restriction on required project ''{0}'')
